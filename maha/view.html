<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Flashlight Model Viewer</title>
  <style>
    body { margin:0; overflow:hidden; background:black; }
  </style>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>

<script>
  const dataStr = localStorage.getItem('lightingModelData');
  if (!dataStr) {
    alert('No lighting model data found in localStorage.');
    throw new Error('No data');
  }
  const data = JSON.parse(dataStr);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);
  scene.fog = new THREE.Fog(0x111111, 10, 100);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(data.roomLength, data.roomLength, data.roomLength);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Floor
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(500, 500),
    new THREE.MeshStandardMaterial({ color: 0x333333 })
  );
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.3));
  const mainLight = new THREE.DirectionalLight(0xffffff, 0.5);
  mainLight.position.set(20, 50, 20);
  mainLight.castShadow = true;
  scene.add(mainLight);

  // Function to make flashlight shape (grouped so we can rotate it easily)
  function createFlashlightModel(targetPos) {
    const group = new THREE.Group();

    // Handle
    const handle = new THREE.Mesh(
      new THREE.CylinderGeometry(0.3, 0.3, 2, 16),
      new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.3, roughness: 0.6 })
    );
    handle.position.y = 1;
    handle.castShadow = true;
    group.add(handle);

    // Head
    const head = new THREE.Mesh(
      new THREE.CylinderGeometry(0.45, 0.45, 0.4, 16),
      new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.4, roughness: 0.5 })
    );
    head.position.y = 2.2;
    head.castShadow = true;
    group.add(head);

    // Lens
    const lens = new THREE.Mesh(
      new THREE.CircleGeometry(0.42, 32),
      new THREE.MeshStandardMaterial({ color: 0xffffcc, emissive: 0xffffaa, emissiveIntensity: 0.5 })
    );
    lens.rotation.x = -Math.PI / 2;
    lens.position.y = 2.4;
    group.add(lens);

    // Light beam cone
    const beamGeometry = new THREE.ConeGeometry(3, 8, 32, 1, true);
    const beamMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffaa,
      transparent: true,
      opacity: 0.15,
      side: THREE.DoubleSide
    });
    const beam = new THREE.Mesh(beamGeometry, beamMaterial);
    beam.position.y = -2;
    beam.rotation.x = Math.PI;
    group.add(beam);

    // Spotlight
    const spotLight = new THREE.SpotLight(0xffffaa, 1.5, 30, Math.PI / 6, 0.5, 1);
    spotLight.position.set(0, 2.4, 0);
    spotLight.castShadow = true;
    group.add(spotLight);

    const target = new THREE.Object3D();
    target.position.copy(targetPos);
    spotLight.target = target;
    scene.add(target);

    // Rotate group to face the target
    group.lookAt(targetPos);

    return group;
  }

  // Place flashlights
  const { fixtures, spacingX, spacingY, roomLength, roomWidth } = data;
  let cols = Math.round(Math.sqrt(fixtures)) || 1;
  let rows = Math.ceil(fixtures / cols);

  if (spacingX > 0 && spacingY > 0) {
    const approxCols = Math.max(1, Math.round(roomLength / spacingX));
    const approxRows = Math.max(1, Math.round(roomWidth / spacingY));
    if (approxCols * approxRows >= fixtures) {
      cols = approxCols;
      rows = approxRows;
    }
  }

  const startX = - (cols - 1) * spacingX / 2;
  const startZ = - (rows - 1) * spacingY / 2;

  const roomCenter = new THREE.Vector3(0, 0, 0); // aiming point

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const index = r * cols + c;
      if (index >= fixtures) break;
      const x = startX + c * spacingX;
      const y = 10;
      const z = startZ + r * spacingY;

      const flashlight = createFlashlightModel(roomCenter);
      flashlight.position.set(x, y, z);
      scene.add(flashlight);
    }
  }

  // Controls
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 0, 0);
  controls.update();

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
