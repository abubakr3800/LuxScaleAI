<!doctype html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Layout from localStorage — 3D labels</title>
  <style>body{margin:0;overflow:hidden;background:#111;} canvas{display:block;}</style>
</head>
<body>

<!-- three + controls -->
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>

<script>
/* -------------------------
 Read data from localStorage
 Expected example:
 {"fixtures":163,"spacingX":4,"spacingY":7,"roomLength":270,"roomWidth":15}
 If missing: we write sample provided by you.
--------------------------*/
let raw = localStorage.getItem('lightingModelData');
if (!raw) {
  raw = JSON.stringify({"fixtures":163,"spacingX":4,"spacingY":7,"roomLength":270,"roomWidth":15});
  localStorage.setItem('lightingModelData', raw);
}
const data = JSON.parse(raw);
console.log('lightingModelData:', data);

/* ----- scene ----- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x20242b);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 3000);
camera.position.set(Math.max(data.roomLength,data.roomWidth)*0.8, Math.max(data.roomLength,data.roomWidth)*0.45, Math.max(data.roomLength,data.roomWidth)*0.6);
camera.lookAt(0,0,0);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;

/* lights */
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(50,200,100); scene.add(sun);

/* ----- room params ----- */
const fixtures = Math.max(1, Number(data.fixtures) || 1);
const spacingX = Math.max(0.01, Number(data.spacingX) || 4);
const spacingY = Math.max(0.01, Number(data.spacingY) || 7);
const roomLength = Math.max(1, Number(data.roomLength) || 270); // Z
const roomWidth  = Math.max(1, Number(data.roomWidth)  || 15);  // X

const wallHeight = Math.max(3, Math.min(30, Math.round(Math.max(6, roomWidth/2)))); // or fixed if you want
const wallThickness = 0.5;

/* ----- floor & roof ----- */
const floorMat = new THREE.MeshStandardMaterial({color:0x2a2a2a});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomLength), floorMat);
floor.rotation.x = -Math.PI/2;
floor.position.y = 0;
scene.add(floor);

const roofMat = new THREE.MeshStandardMaterial({color:0xdcdcdc, side:THREE.DoubleSide});
const roof = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomLength), roofMat);
roof.rotation.x = Math.PI/2;
roof.position.y = wallHeight;
scene.add(roof);

/* ----- walls ----- */
// front wall will have door hole (extruded)
const wallMat = new THREE.MeshStandardMaterial({color:0xbfbfbf, side:THREE.DoubleSide});

// front wall with door hole
const doorWidth = Math.min(Math.max(2, roomWidth * 0.25), roomWidth - 1);
const doorHeight = Math.min( Math.max(2.2, wallHeight - 1), wallHeight - 0.5 );

const shape = new THREE.Shape();
shape.moveTo(-roomWidth/2, 0);
shape.lineTo(roomWidth/2, 0);
shape.lineTo(roomWidth/2, wallHeight);
shape.lineTo(-roomWidth/2, wallHeight);
shape.closePath();

const hole = new THREE.Path();
hole.moveTo(-doorWidth/2, 0);
hole.lineTo(doorWidth/2, 0);
hole.lineTo(doorWidth/2, doorHeight);
hole.lineTo(-doorWidth/2, doorHeight);
hole.closePath();
shape.holes.push(hole);

const extrudeSettings = { depth: wallThickness, bevelEnabled:false };
const frontWallGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
const frontWall = new THREE.Mesh(frontWallGeo, wallMat);
frontWall.rotation.y = Math.PI; // extrude direction corrected
frontWall.position.z = roomLength/2 + wallThickness/2;
scene.add(frontWall);

// back wall
const backWall = new THREE.Mesh(new THREE.BoxGeometry(roomWidth, wallHeight, wallThickness), wallMat);
backWall.position.set(0, wallHeight/2, -roomLength/2 - 0);
scene.add(backWall);

// right & left
const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, roomLength + wallThickness*2), wallMat);
rightWall.position.set(roomWidth/2 + wallThickness/2, wallHeight/2, 0);
scene.add(rightWall);

const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, roomLength + wallThickness*2), wallMat);
leftWall.position.set(-roomWidth/2 - wallThickness/2, wallHeight/2, 0);
scene.add(leftWall);

/* optional door leaf visual */
const doorLeaf = new THREE.Mesh(new THREE.BoxGeometry(doorWidth*0.98, doorHeight, 0.08), new THREE.MeshStandardMaterial({color:0x6b3e1e}));
doorLeaf.position.set(0, doorHeight/2, roomLength/2 + 0.05);
scene.add(doorLeaf);

/* ----- compute grid (match localStorage exactly) ----- */
/* columns formula: number of positions across width using spacing:
   cols = floor(roomWidth / spacingX) + 1  (positions counted inclusive)
   rows computed to accommodate fixtures: rows = ceil(fixtures / cols)
   then if rows > maxRows (fit along length) we switch strategy: use maxRows and increase cols.
*/
let maxCols = Math.floor(roomWidth / spacingX) + 1;
if (maxCols < 1) maxCols = 1;
let cols = maxCols;
let rows = Math.ceil(fixtures / cols);

let maxRows = Math.floor(roomLength / spacingY) + 1;
if (maxRows < 1) maxRows = 1;

if (rows > maxRows) {
  rows = maxRows;
  cols = Math.ceil(fixtures / rows);
}

// Ensure grid fits: if cols would overflow physical width, we accept that spacing may be smaller than given (but here we keep spacing constant)
// We'll center the grid inside room extents.
const gridWidth = (cols - 1) * spacingX;
const gridLength = (rows - 1) * spacingY;
const startX = - gridWidth / 2;
const startZ = - gridLength / 2;

const mountY = wallHeight - 1.0; // height where fixtures mount

// small fixture model
function createFixtureModel(){
  const g = new THREE.Group();
  const metal = new THREE.MeshStandardMaterial({color:0x333333, metalness:0.6, roughness:0.4});
  const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.25,12), metal);
  stem.position.y = -0.125; g.add(stem);
  const dome = new THREE.Mesh(new THREE.SphereGeometry(0.6,24,12,0,Math.PI*2,0,Math.PI/2), metal);
  dome.position.y = -0.65; g.add(dome);
  const lens = new THREE.Mesh(new THREE.CircleGeometry(0.55,32), new THREE.MeshBasicMaterial({color:0xfff6c8, transparent:true, opacity:0.95}));
  lens.rotation.x = -Math.PI/2; lens.position.y = -1.05; g.add(lens);
  const glow = new THREE.Mesh(new THREE.SphereGeometry(0.12,8,6), new THREE.MeshBasicMaterial({color:0xfff6c8, transparent:true, opacity:0.9}));
  glow.position.y = -1.05; g.add(glow);
  return g;
}
const baseFixture = createFixtureModel();

// place fixtures row-major until fixtures reached
let placed = 0;
for (let r = 0; r < rows && placed < fixtures; r++) {
  for (let c = 0; c < cols && placed < fixtures; c++) {
    const fx = baseFixture.clone();
    const x = startX + c * spacingX;
    const z = startZ + r * spacingY;
    fx.position.set(x, mountY, z);
    scene.add(fx);
    placed++;
  }
}
console.log('Placed', placed, 'fixtures  (cols x rows =', cols, 'x', rows, ')');

/* ----- helpers: create 3D facing labels (sprites) ----- */
function makeLabelSprite(text, opts = {}) {
  const font = opts.font || "24px Arial";
  const padding = opts.padding || 8;
  const bg = opts.bg || "rgba(0,0,0,0.6)";
  const color = opts.color || "#ffffff";

  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = font;
  const metrics = ctx.measureText(text);
  const textWidth = Math.ceil(metrics.width);
  const w = textWidth + padding*2;
  const h = parseInt(font,10) + padding*2;

  canvas.width = w;
  canvas.height = h;
  // draw background
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,w,h);
  // text
  ctx.fillStyle = color;
  ctx.font = font;
  ctx.textBaseline = 'middle';
  ctx.fillText(text, padding, h/2);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  const material = new THREE.SpriteMaterial({ map: texture, depthTest: false, sizeAttenuation: false });
  const sprite = new THREE.Sprite(material);
  // scale sprite to reasonable screen-size (pixel-based because sizeAttenuation=false)
  const scale = opts.scale || 0.5;
  sprite.scale.set(w * scale / 40, h * scale / 40, 1);
  return sprite;
}

/* ----- add dimension labels ----- */
// room width label (X)
const widthLabel = makeLabelSprite(`عرض = ${roomWidth}`, {font:"28px Arial", padding:10});
widthLabel.position.set(0, 0.5, gridLength/2 + 1); // place slightly outside front of distribution
scene.add(widthLabel);

// room length label (Z) — rotate to align along X so it reads normally
const lengthLabel = makeLabelSprite(`طول = ${roomLength}`, {font:"28px Arial", padding:10});
lengthLabel.position.set(gridWidth/2 + 1, 0.5, 0);
lengthLabel.material.rotation = -Math.PI/2;
scene.add(lengthLabel);

// wall height label (Y)
const heightLabel = makeLabelSprite(`ارتفاع = ${wallHeight}`, {font:"26px Arial", padding:8});
heightLabel.position.set(-gridWidth/2 - 1, wallHeight/2, -gridLength/2 - 1);
scene.add(heightLabel);

// spacing labels: draw one horizontal spacing between first two columns (if cols>1)
if (cols > 1) {
  const sx = startX;
  const zForSpacing = startZ - 1; // little offset toward front for readability
  // line between pos0 and pos1
  const p0 = new THREE.Vector3(sx, 0.2, zForSpacing);
  const p1 = new THREE.Vector3(sx + spacingX, 0.2, zForSpacing);
  const geo = new THREE.BufferGeometry().setFromPoints([p0,p1]);
  const line = new THREE.Line(geo, new THREE.LineBasicMaterial({color:0xffcc00}));
  scene.add(line);
  const sLabel = makeLabelSprite(`spacingX = ${spacingX}`, {font:"20px Arial", padding:6});
  sLabel.position.set((p0.x + p1.x)/2, 0.6, zForSpacing);
  scene.add(sLabel);
}

// vertical spacing label between first two rows (if rows>1)
if (rows > 1) {
  const sz = startZ;
  const xForSpacing = startX - 1;
  const p0 = new THREE.Vector3(xForSpacing, 0.2, sz);
  const p1 = new THREE.Vector3(xForSpacing, 0.2, sz + spacingY);
  const geo = new THREE.BufferGeometry().setFromPoints([p0,p1]);
  const line = new THREE.Line(geo, new THREE.LineBasicMaterial({color:0x66ccff}));
  scene.add(line);
  const sLabel = makeLabelSprite(`spacingY = ${spacingY}`, {font:"20px Arial", padding:6});
  sLabel.position.set(xForSpacing, 0.6, (p0.z + p1.z)/2);
  scene.add(sLabel);
}

/* label grid corners and show small markers for corners */
const cornerMat = new THREE.MeshStandardMaterial({color:0xffcc00});
const corners = [
  new THREE.Vector3(-gridWidth/2, 0.05, -gridLength/2),
  new THREE.Vector3(gridWidth/2, 0.05, -gridLength/2),
  new THREE.Vector3(gridWidth/2, 0.05, gridLength/2),
  new THREE.Vector3(-gridWidth/2, 0.05, gridLength/2)
];
corners.forEach((p, idx) => {
  const m = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.02,0.2), cornerMat);
  m.position.copy(p);
  scene.add(m);
  const lbl = makeLabelSprite(`C${idx+1}`, {font:"16px Arial", padding:6});
  lbl.position.set(p.x, 0.8, p.z);
  scene.add(lbl);
});

/* small outline box around distribution (wire) */
const outlinePoints = [
  new THREE.Vector3(-gridWidth/2 - 0.4, 0.12, -gridLength/2 - 0.4),
  new THREE.Vector3(gridWidth/2 + 0.4, 0.12, -gridLength/2 - 0.4),
  new THREE.Vector3(gridWidth/2 + 0.4, 0.12, gridLength/2 + 0.4),
  new THREE.Vector3(-gridWidth/2 - 0.4, 0.12, gridLength/2 + 0.4),
  new THREE.Vector3(-gridWidth/2 - 0.4, 0.12, -gridLength/2 - 0.4)
];
const outlineGeo = new THREE.BufferGeometry().setFromPoints(outlinePoints);
const outlineLine = new THREE.Line(outlineGeo, new THREE.LineBasicMaterial({color:0xffcc00}));
scene.add(outlineLine);

/* ----- animate ----- */
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  // make labels face camera (sprites already face camera, but if you used sizeAttenuation=false they stay readable)
  renderer.render(scene, camera);
}
animate();

/* responsiveness */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
